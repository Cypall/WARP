/**************************************************************************\
*                                                                          *
*   Copyright (C) 2020-2021 CH.C (jchcc), Neo-Mind                         *
*                                                                          *
*   This file is a part of WARP project (specific to RO clients)           *
*                                                                          *
*   WARP is free software: you can redistribute it and/or modify           *
*   it under the terms of the GNU General Public License as published by   *
*   the Free Software Foundation, either version 3 of the License, or      *
*   (at your option) any later version.                                    *
*                                                                          *
*   This program is distributed in the hope that it will be useful,        *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
*   GNU General Public License for more details.                           *
*                                                                          *
*   You should have received a copy of the GNU General Public License      *
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
*                                                                          *
*                                                                          *
|**************************************************************************|
*                                                                          *
*   Author(s)     : CH.C (jchcc), Neo-Mind                                 *
*   Created Date  : 2020-11-12                                             *
*   Last Modified : 2021-07-28                                             *
*                                                                          *
\**************************************************************************/

// TODO - Pattern for the newer clients is changed again. Need to experiment with live client

///
/// \brief Changes the dimensions being PUSHed for creating Player's HP/SP Bar
///
ResizePlayerBar = function()
{
	const _ = 'ResizePlayerBar : ';

	$$(_ + '1.1 - Find the original size PUSHes')
	let prefix =
		MOV(ECX, [R32, POS2WC])  //mov ecx, dword ptr [regA + dispA]
	+	PUSH(POS4WC)             //push immA
	+	PUSH(POS4WC)             //push immB
	+	CALL(ALLWC)              //call func#1
	+	MOV(ECX, [R32, POS2WC])  //mov ecx, dword ptr [regA + dispA]
	;

	const suffix =
		PUSH(9)                  //push 9
	+	PUSH(0x3C)               //push 3Ch
	;

	let addr = Exe.FindHex(prefix + suffix);
	if (addr < 0 && Exe.Version === 6) //VC6 2nd form
	{
		prefix =
			MOV([R32, POS1WC], R32) //mov dword ptr [regB + dispB], regC
		+	MOV(ECX, [R32, POS2WC]) //mov ecx, dword ptr [regA + dispC]
		;
		addr = Exe.FindHex(prefix + suffix);
	}
	if (addr < 0)
		throw Error("Size PUSHes missing");

	const sizeAddr = addr + prefix.byteCount();

	$$(_ + '1.2 - Find the reference assignment before the half width subtraction')
	let addrs = Exe.FindHexN( MOV([EAX, WCp], 0x32FF32) );    //mov dword ptr [eax + disp8D], 32FF32h
	if (addrs.isEmpty())
	{
		addrs = Exe.FindHexN( MOV([EAX, POS2WC], 0x32FF32) ); //mov dword ptr [eax + dispD], 32FF32h
	}
	if (addrs.length !== 2)
		throw Error("Invalid no of matches found");

	$$(_ + '1.3 - Now find the subtraction after it. The pattern changes a lot between 2008 - 2019 so this is the only foolproof way')
	const MovEAX = MOV(EAX, 0x88888889); //mov eax, 88888889h

	const halfAddr = addrs.findAs( memAddr =>
	{
		const addr = Exe.FindHex(MovEAX, memAddr + 10, memAddr + 0x80);
		if (addr > 0)
		{
			const result = FindInstr(_RPB_SubTest, memAddr, memAddr + 0x80);
			if (result)
				return result.Addr;
		}
	});
	if (!halfAddr)
		throw Error("Half Width subtraction missing");

	$$(_ + '2.1 - Get the new dimensions from user')
	const result = Exe.GetUserInput('$pcHPBarSize', D_VecI8, "Player HP Bar Dimensions", "Enter the new HP bar size for Player (in pixels)", [60, 9], {
		name0: "Bar Width", min0: 1,
		name1: "Bar Height", min1: 1,
	});
	if (result === false)
		Cancel("Size", "(60 x 9)");

	const [wid, hgt] = result;

	$$(_ + '2.2 - Replace at all the locations')
	if (wid !== 60)
	{
		Exe.SetInt8(sizeAddr + 3, wid);
		Exe.SetUint8(halfAddr + 2, wid >> 1);
	}

	if (hgt !== 9)
	{
		Exe.SetInt8(sizeAddr + 1, hgt);
	}

	return true;
};

///
/// \brief Testing function for finding the SUB reg32, 1E instruction
///
_RPB_SubTest = (ins) =>
	ins.Codes[0] === 0x83 && ins.Immd === 0x1E && ins.MRM.RegO === 5;


// TODO - No matching code found for clients before 2012-04-10RE . Looks like its using PUSH 5 & PUSH 3C again
//        Need to try in live client to find the correct one.


///
/// \brief Data to be used for the patches
///
if (typeof RMB_Data === 'undefined') //avoid redefinition
{
	RMB_Data = {
		varNames = ['$normalBarSize', '$miniBossBarSize', '$bossBarSize'],
		prefix = ["Normal", "Mini-Boss", "Boss"],
	};
	RMB_Patches = ["ResizeNormalBar", "ResizeMiniBossBar", "ResizeBossBar"];
}

///
/// \brief Modifies the size values being pushed to create the health bar of Mobs based on the mob type flag.
///
ResizeMobBar = function(patchName)
{
	const _ = patchName + ' : ';

	if ( !('HookAddr' in RMB_Data) )
	{
		if (Exe.BuildDate < 20160000)
		{
			RMB_Data.Mode = 1; //older style

			$$(_ + '1.1 - Initialize the default widths & heights')
			RMB_Data.DefW = [0x3C, 0x64, 0x8C];
			RMB_Data.DefH = [0x5, 0xB, 0x11];

			$$(_ + '1.2 - Find the size calculation & PUSHes')
			const parts =
			[//0
				LEA(R32, [2, R32, R32])                         //lea regA, [regB*2 + regB]
			+	LEA(R32, [Exe.Version < 11 ? R32 : 2, R32, 5])  //lea regA, [regA*2 + 5] OR lea regA, [regA + regA + 5]
			+	PUSH_R                                          //push regA ; height
			+	LEA(R32, [4, R32, R32])                         //lea regA, [regB*4 + regB]

			,//1
				(Exe.Version >= 11 ? MOV(ECX, R32) : "")        //mov ecx, regC ; only there in old clients
			+	LEA(R32, [8, R32, 0x3C])                        //lea regA, [regA*8 + 3Ch]
			+	PUSH_R                                          //push regA ; width
			];
			const addr = Exe.FindHex(parts);
			if (addr < 0)
				throw Error("Size assignment missing");

			$$(_ + '1.3 - Save the addresses and the code size')
			RMB_Data.HookAddr = addr;
			RMB_Data.OvrdSize = parts.byteCount();
			RMB_Data.RetnAddr = Exe.Phy2Vir(addr + RMB_Data.OvrdSize, CODE);

			$$(_ + '1.4 - Extract the register being used in the multiplication which contains the mob type flag')
			const ins = Instr.FromAddr(addr);
			RMB_Data.MobType = R32.List[ins.SIB.Base];

			$$(_ + '1.5 - Save the MOV ECX instruction if applicable')
			RMB_Data.MovECX = Exe.Version >= 11 ? Instr.FromAddr(addr + parts.byteCount(0)) : '';
		}
		else
		{
			RMB_Data.Mode = 2; //newer style

			$$(_ + '2.1 - Initialize the default widths & heights')
			RMB_Data.DefW = [0x3C, 0x3C, 0x3C];
			RMB_Data.DefH = [0x5, 0x5, 0x5];

			$$(_ + '2.2 - Save the ECX assignment')
			RMB_Data.MovECX = MOV(ECX, EAX);

			$$(_ + '2.3 - Find the size PUSHes (the pattern matches multiple times)')
			let parts =
			[//0
				PUSH(5)                  //push 5
			+	PUSH(60)                 //push 3Ch

			,//1
				RMB_Data.MovECX          //mov ecx, eax

			,//2
				MOV([R32, POS2WC], EAX)  //mov dword ptr [regC + dispC], eax
			+	CALL()                   //call func#1
			];

			let addrs = Exe.FindHexN(parts);
			if (addrs.isEmpty())
			{
				[parts[1], parts[0]] = [parts[0], parts[1]]; //swap the first 2 parts (MOV need to be before PUSHes)

				addrs = Exe.FindHexN(parts);
			}
			if (addrs.isEmpty())
				throw Error("PUSH pattern missing");

			$$(_ + '2.4 - Filter out the correct PUSH based on the code before it')
			const hookAddr = addrs.find(memAddr =>
			{
				let code2 =
					CMP(EBX, -1)			//cmp ebx, -1
				+	JE(POS2WC)				//je _skip
				+	MOV(ESI, [EBP, WCp])	//mov esi, dword ptr [ebp + disp8A] ; ARG.x
				+	CMP(ESI, -1)			//cmp esi, -1
				;
				let addr = Exe.FindHex(code2, memAddr - 0xA0, memAddr);
				if (addr < 0)
				{
					code2 = code2.replace(
						JE(POS2WC),				//change JE _skip
						                        //  TO
						JNE(WCp)				//jne short _skip#2
					+	CMP([EBP, NEG2WC], EBX)	//cmp dword ptr [LOCAL.x], ebx
					+	JE(WCp)					//je short _skip#3
					);

					addr = Exe.FindHex(code2, memAddr - 0xF0, memAddr);
				}
				return (addr > 0);
			});
			if (!hookAddr)
				throw Error("No proper size PUSHes found");

			$$(_ + '2.5 - Save the addresses and the code size')
			RMB_Data.HookAddr = hookAddr;
			RMB_Data.OvrdSize = 6; //2 for the 1 byte PUSH + 4 for the 4 byte PUSH
			RMB_Data.RetnAddr = Exe.Phy2Vir(hookAddr + 6);

			$$(_ + '2.6 - Extract the memory location & update the displacement to mob type flag')
			const ins = Instr.FromAddr(hookAddr + parts.byteCount(0, 1));
			RMB_Data.MobType = [R32.List[ins.MRM.RegM], ins.Disp + 4];
		}

		$$(_ + '3.1 - Copy the defaults to the current Width & Height array')
		RMB_Data.W = [...RMB_Data.DefW];
		RMB_Data.H = [...RMB_Data.DefH];
	}

	$$(_ + '3.1 - Retrieve the default dimensions for the bar')
	const idx = RMB_Patches.indexOf(patchName);
	const oldW = RMB_Data.DefW[idx];
	const oldH = RMB_Data.DefH[idx];

	$$(_ + '3.2 - Get the new dimensions from user')
	const prefix = RMB_Data.prefix[idx];
	const result = Exe.GetUserInput(RMB_Data.varNames[idx], D_VecU8, `${prefix} Mob HP Bar Dimensions`, `Enter the new HP bar size for ${prefix} monsters (in pixels)`, [60, 5], {
		name0: "Bar Width", min0: 1,
		name1: "Bar Height", min1: 1,
	});
	if (result === false)
	{
		RMB_Data.W[idx] = oldW;//restoring old values
		RMB_Data.H[idx] = oldH;

		Cancel("Size", `(${oldW} x ${oldH})`);
	}

	[RMB_Data.W[idx], RMB_Data.H[idx]] = result;

	$$(_ + '3.3 - Call the helper function to stage the changes')
	_RMB_Stage(patchName);

	return true;
};

///
/// \brief Helper function to stage the changes (helpful with transference in case 1 patch gets disabled)
///
_RMB_Stage = (patchName) =>
{
	const _ = patchName + '- Staging : '
	$$(_ + '1 - Clear the changes in the other patches')
	for (const name of RMB_Patches)
	{
		if (name === patchName)
			continue;

		if (Warp.GetPatchState(name))
			Exe.ClearPatch(name);
	}

	$$(_ + '2.1 - Construct our code')
	const parts =
	[//0
		CMP(BYTE_PTR, RMB_Data.MobType, 2)  //cmp byte ptr [regC + mobType], 2  OR  cmp regC, 2
	+	JNE(Filler(1,1))                    //jne _checkMini
	+	PUSH(RMB_Data.H[2])                 //push <bossHeight>
	+	PUSH(RMB_Data.W[2])                 //push <bossWidth>
	+	RMB_Data.MovECX                     //mov ecx, regA
	+	JMP(Filler(3))                      //jmp <retnAddr>

	,//1
		CMP(BYTE_PTR, RMB_Data.MobType, 1)  //cmp byte ptr [regC + mobType], 1  OR  cmp regC, 1 ; _checkMini
	+	JNE(Filler(2,1))                    //jne _isNormal
	+	PUSH(RMB_Data.H[1])                 //push <miniBossHeight>
	+	PUSH(RMB_Data.W[1])                 //push <miniBossWidth>
	+	RMB_Data.MovECX                     //mov ecx, regA
	+	JMP(Filler(3))                      //jmp <retnAddr>

	,//2
		PUSH(RMB_Data.H[0])                 //push <normalHeight> ; _isNormal
	+	PUSH(RMB_Data.W[0])                 //push <normalWidth>
	+	RMB_Data.MovECX                     //mov ecx, regA
	+	JMP(Filler(3))                      //jmp <retnAddr>
	];

	$$(_ + '2.2 - Allocate space for it')
	const [free, freeVir] = Exe.FindSpace(parts.byteCount(), 0x10);

	$$(_ + '2.3 - Fill in the blanks')
	const [,_checkMini, _isNormal] = MapAddrs(freeVir, parts);
	const code = SetFillTargets( parts,
	{
		start : freeVir,
		'1,1' : _checkMini,
		'2,1' : _isNormal,
		    3 : RMB_Data.RetnAddr
	});

	$$(_ + '2.4 - Add at allocated space')
	Exe.AddHex(free, code);

	$$(_ + '2.5 - Setup a JMP to it at hook address')
	Exe.SetJMP(RMB_Data.HookAddr, freeVir, RMB_Data.OvrdSize - 5); //NOPs at the end to keep it clean.

	$$(_ + '2.6 - Indicate the patch has the changes')
	RMB_Data.Stager = patchName;
};

///
/// \brief Unset the width & height overrides and transfers the staged changes to one of the other active patches.
///
ResizeMobBar.cleanup = function(patchName)
{
	const _ = patchName + '.cleanup : ';

	$$(_ + '1 - Reset the dimensions to default')
	const idx = RMB_Patches.indexOf(patchName);

	RMB_Data.W[idx] = RMB_Data.DefW[idx];
	RMB_Data.H[idx] = RMB_Data.DefH[idx];

	$$(_ + '2 - If the changes are not staged on this patch then re-run the helper function, so that the default W x H is used')
	if (RMB_Data.Stager !== patchName)
	{
		Exe.ClearPatch(RMB_Data.Stager);
		_RMB_Stage(RMB_Data.Stager);

		return;
	}

	$$(_ + '3 - If the changes were staged on this patch then re-run the helper function with another active patch')
	for (const name of RMB_Patches)
	{
		if (name === patchName)
			continue;

		if (Warp.GetPatchState(name))
		{
			_RMB_Stage(name);
			break;
		}
	}
};

///
/// \brief Wrappers over the individual patches
///
ResizeNormalBar   = ResizeMobBar;
ResizeMiniBossBar = ResizeMobBar;
ResizeBossBar     = ResizeMobBar;
