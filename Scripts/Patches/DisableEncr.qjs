/**************************************************************************\
*                                                                          *
*   Copyright (C) ?-2021 Ai4rei/AN                                         *
*   Copyright (C) 2013-2021 Neo-Mind                                       *
*                                                                          *
*   This file is a part of WARP project (specific to RO clients)           *
*                                                                          *
*   WARP is free software: you can redistribute it and/or modify           *
*   it under the terms of the GNU General Public License as published by   *
*   the Free Software Foundation, either version 3 of the License, or      *
*   (at your option) any later version.                                    *
*                                                                          *
*   This program is distributed in the hope that it will be useful,        *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
*   GNU General Public License for more details.                           *
*                                                                          *
*   You should have received a copy of the GNU General Public License      *
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
*                                                                          *
*                                                                          *
|**************************************************************************|
*                                                                          *
*   Author(s)     : Ai4rei/AN, Neo-Mind                                    *
*   Created Date  : 2020-11-10                                             *
*   Last Modified : 2021-07-25                                             *
*                                                                          *
\**************************************************************************/

///
/// \brief Make the code inside CLoginMode::OnChangepktON which sends 0x2B0,
///        use the original password (available as argument 1) instead of encrypted one
///
NoLoginEncr = function()
{
	const _ = 'NoLoginEncr : ';

	$$(_ + '1.1 - Find Encryptor function CALL')
	let code =
		PUSH_R        //push regA
	+	CALL(NEG3WC)  //call Encryptor
	+	MOV(ECX, 6)   //mov ecx, 6
	+	LEA() 		  //lea regB, [LOCAL.x]
	;
	let addr = Exe.FindHex(code);
	if (addr < 0)
		throw Error("Encryptor CALL not found");

	$$(_ + '1.2 - Extract the register PUSHed before the CALL (i.e. Arg.1). It has the unencrypted password')
	const regNum = Exe.GetUint8(addr) - 0x50;

	$$(_ + '1.3 - Set addr to location of LEA')
	addr += code.byteCount() - 1;

	$$(_ + '2 - Change source argument in LEA from EBP-x to register specified by regNum')
	const ins = Instr.FromAddr(addr);
	const regB = R32.List[ins.MRM.RegO];
	const regA = R32.List[regNum];

	code =
		LEA(regB, [regA])         //lea regB, [regA]
	+   NOP.repeat(ins.Size - 2)  //NOP fill rest of the space
	;

	Exe.SetHex(addr, code);
	return true;
};

///
/// \brief Find call to the encryption function and substitute it with XOR EAX, EAX
///
NoPacketEncr = function()
{
	const _ = 'NoPacketEncr : ';

	$$(_ + '1.1 - Ensure all the Packet Key patches are deselected (unless in test mode)')
	if (!Warp.TestMode)
	{
		for (const name of PktKeyPatches)
			Warp.SetPatchState(name, false);
	}

	$$(_ + '1.2 - Ensure the PACKET object has been loaded with valid data')
	PACKET.load();

	// Now we diverge a little based on how the keys are assigned.
	if (PACKET.KS_Mode === KeyMode.Push)
	{
		$$(_ + '2.1 - Find the Packet Encryption CALL (may or may not be PACKET.KeySetter)')
		const code =
			PACKET.MovECX    //mov ecx, dword ptr [KeyAddr]
		+	CALL()			 //call CRagConnection::Encryptor
		;

		const addr = Exe.FindHex(code);
		if (addr < 0)
			throw Error("Encryption CALL not found");

		$$(_ + '2.2 - Change the MOV & CALL to EAX = 0 followed by NOPs (internally could be JMP to skip over code)')
		Exe.SetHex(addr, XOR(EAX, EAX));
		Exe.SetNOPs(addr + 2, code.byteCount() + 2);
	}
	else
	{
		$$(_ + '3.1 - Retrieve the PHYSICAL address of the KeySetter (which serves as the obfuscator/encryptor as well)')
		const addr = Exe.Vir2Phy(PACKET.KeySetter, CODE);

		$$(_ + '3.2 - Change it to EAX = 0 and RETN 4. It will affect all the CALLs but it shouldnt matter')
		Exe.SetHex(addr, XOR(EAX, EAX) + RETN(4));
	}

	return true;
};

///
/// \brief Disable for unsupported clients
///
NoLoginEncr.validate  = () =>
	Exe.BuildDate > 20080600 && Exe.BuildDate < 20100803;

NoPacketEncr.validate = HasPktKeys;
